# 存储系统
## 芯片
RAM和ROM都是半导体存储器，RAM为随机存取存储器，ROM为只读存储器
### SRAM
静态随机存取存储器<br>
运用双稳态触发器存储数据，数据一旦被写入，只要不断电，数据就保持不变<br>
速度非常快，但是每个单元需要更多晶体管，所以成本高，集成度低并且还占用更多空间。<br>
一般用于高速缓存存储器。
### DRAM
动态随机存取存储器<br>
运用电容存储数据，电容回自然放电，所以需要定时刷新来保持数据的完整性<br>
速度比SRAM慢，每个存储元一般只用一个晶体管，密度比SRAM高很多，成本低，集成度高，容量大，功耗低<br>
一般用于大容量主存系统。<br>
DRAM的刷新
+ 集中刷新，在一个刷新周期内选择一段时间，这段时间叫做死期，依次对存储器所有行进行再生，这段时间不能读写存储器
+ 分散刷新，把每行的刷新分散到各个周期，对于存取周期1us，前一半周期0.5us用于读写，后一半0.5us用于刷新，没有死区但是增加了存取周期
+ 异步刷新，刷新周期除以行数，得到时间间隔t，每隔时间t产生一次刷新请求
### ROM
只读存储器

## 主存储器
### 主存储器整体结构
存储体
CPU的MDR直接将数据与存储体交互
+ 存储体由存储单元构成
+ 存储单元由存储元构成
+ 存储元内存放二进制数

地址寄存器
+ 寄存CPU的MAR通过地址线传来的待查询地址

地址译码器
+ 根据地址寄存器中的地址在存储体中找到对应存储单元<br>
![主存储器](https://github.com/user-attachments/assets/96ffc268-2abd-431b-a472-60dfcd673eaf)
### 多模块存储器
#### 多体并行存储器--高位交叉编址
将数据存储在多个不同的模块，其中单个模块中的数据地址是顺序的<br>
将待查询的地址拆分，高位作为模块号（体号），低位作为地址<br>
根据当前模块号去对应模块中查到地址。<br>
就像住酒店，酒店第一个数字一般都是你在几楼，再根据后面数字找到房间号。<br>
由于CPU顺序读取的思想，每次要访问完当前的模块才能继续访问下一模块，所以不能提高存储器的吞吐率<br>
![高位交叉编址](https://github.com/user-attachments/assets/c690c3d5-947b-43ea-9167-a3f6ea4cea8b)
#### 多体并行存储器--低位交叉编址
将数据存储在多个不同的模块，其中单个模块中数据地址和体号还有模块数的关系是：数据地址 % 模块数 = 体号<br>
就是说相邻地址在相邻模块的对应位置<br>
将待查询的地址拆分，高位作为地址号，低位作为模块号（体号）<br>
根据体号查到模块，再根据地址查到数据地址。<br>
由于相邻地址在不同的模块，所以CPU可以不需要等待读取完第一个地址的数据再去读第二个地址的数据，这个时候可以读取完第一条数据后芯片休息时间读取第二条数据<br>
![低位交叉编址](https://github.com/user-attachments/assets/ea6bd8ac-c30f-4815-a227-5b53bf158014)

### 位扩展
例如：8Kx1位芯片扩展成8Kx8位就需要8片，这个时候地址线A0~A7和片选信号CS还有写使能WE都连接在同一位置，数据线则分别连向CPU
![位扩展](https://github.com/user-attachments/assets/930c618b-01bf-4d1f-8f59-961e97aeec01)

### 字扩展
例如：1Kx8位芯片扩展成2Kx8位芯片需要两片芯片并加上相应的地址线,将CS片选信号连接到新添加的地址线上，以CPU控制选择哪块芯片
![字扩展](https://github.com/user-attachments/assets/dfb13276-897c-496b-b8ff-c7febe6cdde0)

### 字位扩展
就是字扩展和位扩展合并在一起

![20240808173531](https://github.com/user-attachments/assets/58b9e420-16f5-43dc-840a-9a989ddf3e0f)

